// @ts-nocheck
import crypto from 'crypto'
import * as snarkjs from 'snarkjs'
import { readFileSync } from 'fs'
import wc from '../build/ZKFactor_js/witness_calculator.js'

import * as binFileUtils from '@iden3/binfileutils'
import * as zkeyUtils from './zkey_utils'
import { getCurveFromQ as getCurve } from './curves'
import { Scalar, utils, BigBuffer } from 'ffjavascript'
const { stringifyBigInts, unstringifyBigInts } = utils
import jsSha3 from 'js-sha3'
const { keccak256 } = jsSha3

const getRandomPrime = (bitLength: number) => {
	return crypto.generatePrimeSync(bitLength, { bigint: true })
}

const getRandomArray = (arraySize: number) => {
	const buffer = crypto.randomBytes(arraySize)
	return new Uint8Array(buffer.buffer)
}

const generatePlonkProof = async (privateInputs: object) => {
	const wasmPath = './build/ZKFactor_js/ZKFactor.wasm'
	const zkeyPath = './build/ZKFactor_final.zkey'

	const wasmBuffer = readFileSync(wasmPath)
	const zkeyBuffer = readFileSync(zkeyPath)

	const witnessCalculator = await wc(wasmBuffer)
	const witnessBuffer = await witnessCalculator.calculateWTNSBin(privateInputs, 0)

	const { proof, publicSignals } = await snarkjs.plonk.prove(zkeyBuffer, witnessBuffer)

	return { proof, publicSignals }
}

const generateForgedPlonkProof = async () => {
	const zkeyFile = readFileSync('./build/ZKFactor_final.zkey')
	const { fd: fdZKey, sections: sectionsZKey } = await binFileUtils.readBinFile(zkeyFile, "zkey", 2, 1 << 25, 1 << 23)

	const zkey = await zkeyUtils.readHeader(fdZKey, sectionsZKey)
	if (zkey.protocol != "plonk") {
		throw new Error("zkey file is not groth16")
	}

	const curve = await getCurve(zkey.q)
	const Fr = curve.Fr
	const G1 = curve.G1
	const n8r = curve.Fr.n8

	let A, B, C, Z
	let A4, B4, C4, Z4
	let pol_a, pol_b, pol_c, pol_z, pol_t, pol_r
	let proof: any = {}

	const sigmaBuff = new BigBuffer(zkey.domainSize * n8r * 4 * 3)
	let o = sectionsZKey[12][0].p + zkey.domainSize * n8r
	await fdZKey.readToBuffer(sigmaBuff, 0, zkey.domainSize * n8r * 4, o)
	o += zkey.domainSize * n8r * 5
	await fdZKey.readToBuffer(sigmaBuff, zkey.domainSize * n8r * 4, zkey.domainSize * n8r * 4, o)
	o += zkey.domainSize * n8r * 5
	await fdZKey.readToBuffer(sigmaBuff, zkey.domainSize * n8r * 8, zkey.domainSize * n8r * 4, o)

	const pol_s1 = new BigBuffer(zkey.domainSize * n8r)
	await fdZKey.readToBuffer(pol_s1, 0, zkey.domainSize * n8r, sectionsZKey[12][0].p)

	const pol_s2 = new BigBuffer(zkey.domainSize * n8r)
	await fdZKey.readToBuffer(pol_s2, 0, zkey.domainSize * n8r, sectionsZKey[12][0].p + 5 * zkey.domainSize * n8r)

	const PTau = await binFileUtils.readSection(fdZKey, sectionsZKey, 14)

	const ch = {}

	await round1()
	await round2()
	await round3()
	await round4()
	await round5()

	///////////////////////
	// Final adjustments //
	///////////////////////

	proof.protocol = "plonk"
	proof.curve = curve.name

	await fdZKey.close()

	// Recover Pl from the equation in Step 8. of Verifier
	let Pl

	const zh_xi = Fr.sub(ch.xim, Fr.one)
	Pl = Fr.mul(proof.eval_t, zh_xi)
	Pl = Fr.sub(Pl, proof.eval_r)

	let rhs0 = Fr.mul(ch.beta, proof.eval_s1)
	rhs0 = Fr.add(rhs0, proof.eval_a)
	rhs0 = Fr.add(rhs0, ch.gamma)

	let rhs1 = Fr.mul(ch.beta, proof.eval_s2)
	rhs1 = Fr.add(rhs1, proof.eval_b)
	rhs1 = Fr.add(rhs1, ch.gamma)

	let rhs2 = Fr.add(proof.eval_c, ch.gamma)

	let rhs3 = Fr.mul(rhs0, rhs1)
	rhs3 = Fr.mul(rhs3, rhs2)
	rhs3 = Fr.mul(rhs3, proof.eval_zw)
	rhs3 = Fr.mul(rhs3, ch.alpha)

	Pl = Fr.add(Pl, rhs3)

	const eval_l1 = Fr.div(
		Fr.sub(ch.xim, Fr.one),
		Fr.mul(Fr.sub(ch.xi, Fr.one), Fr.e(zkey.domainSize))
	)

	let rhs4 = Fr.mul(eval_l1, ch.alpha)
	rhs4 = Fr.mul(rhs4, ch.alpha)

	Pl = Fr.add(Pl, rhs4)

	// Based on the "calculatePl" function on the smart contract
	// (((max_uint256 - ((a*b) % q)) + q) % max_uint256) % q
	const max_uint256 = 2n ** 256n - 1n
	const q = 21888242871839275222246405745257275088548364400416034343698204186575808495617n // BabyJubjub Prime

	Pl = Fr.toObject(Pl)
	Pl = (Pl - q) & max_uint256
	Pl = max_uint256 - Pl +1n
	Pl = Fr.fromObject(Pl)
	
	let w = Fr.div(Pl, eval_l1)
	w = Fr.toObject(w)

	let publicSignals = [w]

	proof.A = G1.toObject(proof.A)
	proof.B = G1.toObject(proof.B)
	proof.C = G1.toObject(proof.C)
	proof.Z = G1.toObject(proof.Z)
	proof.T1 = G1.toObject(proof.T1)
	proof.T2 = G1.toObject(proof.T2)
	proof.T3 = G1.toObject(proof.T3)
	proof.eval_a = Fr.toObject(proof.eval_a)
	proof.eval_b = Fr.toObject(proof.eval_b)
	proof.eval_c = Fr.toObject(proof.eval_c)
	proof.eval_s1 = Fr.toObject(proof.eval_s1)
	proof.eval_s2 = Fr.toObject(proof.eval_s2)
	proof.eval_zw = Fr.toObject(proof.eval_zw)
	proof.eval_r = Fr.toObject(proof.eval_r)
	proof.Wxi = G1.toObject(proof.Wxi)
	proof.Wxiw = G1.toObject(proof.Wxiw)

	proof = stringifyBigInts(proof)
	publicSignals = stringifyBigInts(publicSignals)

	return { proof, publicSignals }

	async function round1() {
		let ABC = []

		for (let idx = 0; idx < 3; idx++) {
			const randomArray = getRandomArray(zkey.domainSize * n8r)
			ABC.push(randomArray)
		}

		[A, B, C] = ABC;

		A = await Fr.batchToMontgomery(A);
		B = await Fr.batchToMontgomery(B);
		C = await Fr.batchToMontgomery(C);

		[pol_a, A4] = await to4T(A);
		[pol_b, B4] = await to4T(B);
		[pol_c, C4] = await to4T(C);

		proof.A = await expTau(pol_a, "multiexp A")
		proof.B = await expTau(pol_b, "multiexp B")
		proof.C = await expTau(pol_c, "multiexp C")
	}

	async function round2() {
		const transcript1 = new Uint8Array(G1.F.n8 * 2 * 3)
		G1.toRprUncompressed(transcript1, 0, proof.A)
		G1.toRprUncompressed(transcript1, G1.F.n8 * 2, proof.B)
		G1.toRprUncompressed(transcript1, G1.F.n8 * 4, proof.C)
		ch.beta = hashToFr(transcript1)

		const transcript2 = new Uint8Array(n8r)
		Fr.toRprBE(transcript2, 0, ch.beta)
		ch.gamma = hashToFr(transcript2)

		pol_z = new BigBuffer(352)
		proof.Z = await expTau(pol_z, "multiexp Z")
	}

	async function round3() {
		const transcript3 = new Uint8Array(G1.F.n8 * 2)
		G1.toRprUncompressed(transcript3, 0, proof.Z)
		ch.alpha = hashToFr(transcript3) // hash of zeros

		const t = getRandomArray(1024) // zkey.domainSize*4*n8r
		pol_t = t.slice(0, (zkey.domainSize * 3 + 6) * n8r)

		proof.T1 = await expTau(t.slice(0, zkey.domainSize * n8r), "multiexp T1")
		proof.T2 = await expTau(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), "multiexp T2")
		proof.T3 = await expTau(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), "multiexp T3")
	}

	async function round4() {
		const pol_qm = new BigBuffer(zkey.domainSize * n8r)
		await fdZKey.readToBuffer(pol_qm, 0, zkey.domainSize * n8r, sectionsZKey[7][0].p)

		const pol_ql = new BigBuffer(zkey.domainSize * n8r)
		await fdZKey.readToBuffer(pol_ql, 0, zkey.domainSize * n8r, sectionsZKey[8][0].p)

		const pol_qr = new BigBuffer(zkey.domainSize * n8r)
		await fdZKey.readToBuffer(pol_qr, 0, zkey.domainSize * n8r, sectionsZKey[9][0].p)

		const pol_qo = new BigBuffer(zkey.domainSize * n8r)
		await fdZKey.readToBuffer(pol_qo, 0, zkey.domainSize * n8r, sectionsZKey[10][0].p)

		const pol_qc = new BigBuffer(zkey.domainSize * n8r)
		await fdZKey.readToBuffer(pol_qc, 0, zkey.domainSize * n8r, sectionsZKey[11][0].p)

		const pol_s3 = new BigBuffer(zkey.domainSize * n8r)
		await fdZKey.readToBuffer(pol_s3, 0, zkey.domainSize * n8r, sectionsZKey[12][0].p + 10 * zkey.domainSize * n8r)

		const transcript4 = new Uint8Array(G1.F.n8 * 2 * 3)
		G1.toRprUncompressed(transcript4, 0, proof.T1)
		G1.toRprUncompressed(transcript4, G1.F.n8 * 2, proof.T2)
		G1.toRprUncompressed(transcript4, G1.F.n8 * 4, proof.T3)
		ch.xi = hashToFr(transcript4)

		proof.eval_a = evalPol(pol_a, ch.xi)
		proof.eval_b = evalPol(pol_b, ch.xi)
		proof.eval_c = evalPol(pol_c, ch.xi)
		proof.eval_s1 = evalPol(pol_s1, ch.xi)
		proof.eval_s2 = evalPol(pol_s2, ch.xi)
		proof.eval_t = evalPol(pol_t, ch.xi)
		proof.eval_zw = evalPol(pol_z, Fr.mul(ch.xi, Fr.w[zkey.power]))

		const coef_ab = Fr.mul(proof.eval_a, proof.eval_b)

		let e2a = proof.eval_a
		const betaxi = Fr.mul(ch.beta, ch.xi)
		e2a = Fr.add(e2a, betaxi)
		e2a = Fr.add(e2a, ch.gamma)

		let e2b = proof.eval_b
		e2b = Fr.add(e2b, Fr.mul(betaxi, zkey.k1))
		e2b = Fr.add(e2b, ch.gamma)

		let e2c = proof.eval_c
		e2c = Fr.add(e2c, Fr.mul(betaxi, zkey.k2))
		e2c = Fr.add(e2c, ch.gamma)

		const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), ch.alpha)

		let e3a = proof.eval_a
		e3a = Fr.add(e3a, Fr.mul(ch.beta, proof.eval_s1))
		e3a = Fr.add(e3a, ch.gamma)

		let e3b = proof.eval_b
		e3b = Fr.add(e3b, Fr.mul(ch.beta, proof.eval_s2))
		e3b = Fr.add(e3b, ch.gamma)

		let e3 = Fr.mul(e3a, e3b)
		e3 = Fr.mul(e3, ch.beta)
		e3 = Fr.mul(e3, proof.eval_zw)
		e3 = Fr.mul(e3, ch.alpha)

		ch.xim = ch.xi
		for (let i = 0; i < zkey.power; i++) ch.xim = Fr.mul(ch.xim, ch.xim)
		const eval_l1 = Fr.div(
			Fr.sub(ch.xim, Fr.one),
			Fr.mul(Fr.sub(ch.xi, Fr.one), Fr.e(zkey.domainSize))
		)

		const e4 = Fr.mul(eval_l1, Fr.mul(ch.alpha, ch.alpha))

		const coefs3 = e3
		const coefz = Fr.add(e2, e4)

		pol_r = new BigBuffer((zkey.domainSize + 3) * n8r)

		for (let i = 0; i < zkey.domainSize + 3; i++) {
			let v = Fr.mul(coefz, pol_z.slice(i * n8r, (i + 1) * n8r))
			if (i < zkey.domainSize) {
				v = Fr.add(v, Fr.mul(coef_ab, pol_qm.slice(i * n8r, (i + 1) * n8r)))
				v = Fr.add(v, Fr.mul(proof.eval_a, pol_ql.slice(i * n8r, (i + 1) * n8r)))
				v = Fr.add(v, Fr.mul(proof.eval_b, pol_qr.slice(i * n8r, (i + 1) * n8r)))
				v = Fr.add(v, Fr.mul(proof.eval_c, pol_qo.slice(i * n8r, (i + 1) * n8r)))
				v = Fr.add(v, pol_qc.slice(i * n8r, (i + 1) * n8r))
				v = Fr.sub(v, Fr.mul(coefs3, pol_s3.slice(i * n8r, (i + 1) * n8r)))
			}
			pol_r.set(v, i * n8r)
		}

		proof.eval_r = evalPol(pol_r, ch.xi)
	}

	async function round5() {
		const transcript5 = new Uint8Array(n8r * 7)
		Fr.toRprBE(transcript5, 0, proof.eval_a)
		Fr.toRprBE(transcript5, n8r, proof.eval_b)
		Fr.toRprBE(transcript5, n8r * 2, proof.eval_c)
		Fr.toRprBE(transcript5, n8r * 3, proof.eval_s1)
		Fr.toRprBE(transcript5, n8r * 4, proof.eval_s2)
		Fr.toRprBE(transcript5, n8r * 5, proof.eval_zw)
		Fr.toRprBE(transcript5, n8r * 6, proof.eval_r)
		ch.v = []
		ch.v[1] = hashToFr(transcript5)

		for (let i = 2; i <= 6; i++) ch.v[i] = Fr.mul(ch.v[i - 1], ch.v[1])

		let pol_wxi = new BigBuffer((zkey.domainSize + 6) * n8r)

		const xi2m = Fr.mul(ch.xim, ch.xim)

		for (let i = 0; i < zkey.domainSize + 6; i++) {
			let w = Fr.zero
			w = Fr.add(w, Fr.mul(xi2m, pol_t.slice((zkey.domainSize * 2 + i) * n8r, (zkey.domainSize * 2 + i + 1) * n8r)))

			if (i < zkey.domainSize + 3) {
				w = Fr.add(w, Fr.mul(ch.v[1], pol_r.slice(i * n8r, (i + 1) * n8r)))
			}

			if (i < zkey.domainSize + 2) {
				w = Fr.add(w, Fr.mul(ch.v[2], pol_a.slice(i * n8r, (i + 1) * n8r)))
				w = Fr.add(w, Fr.mul(ch.v[3], pol_b.slice(i * n8r, (i + 1) * n8r)))
				w = Fr.add(w, Fr.mul(ch.v[4], pol_c.slice(i * n8r, (i + 1) * n8r)))
			}

			if (i < zkey.domainSize) {
				w = Fr.add(w, pol_t.slice(i * n8r, (i + 1) * n8r))
				w = Fr.add(w, Fr.mul(ch.xim, pol_t.slice((zkey.domainSize + i) * n8r, (zkey.domainSize + i + 1) * n8r)))
				w = Fr.add(w, Fr.mul(ch.v[5], pol_s1.slice(i * n8r, (i + 1) * n8r)))
				w = Fr.add(w, Fr.mul(ch.v[6], pol_s2.slice(i * n8r, (i + 1) * n8r)))
			}

			pol_wxi.set(w, i * n8r)
		}

		let w0 = pol_wxi.slice(0, n8r)
		w0 = Fr.sub(w0, proof.eval_t)
		w0 = Fr.sub(w0, Fr.mul(ch.v[1], proof.eval_r))
		w0 = Fr.sub(w0, Fr.mul(ch.v[2], proof.eval_a))
		w0 = Fr.sub(w0, Fr.mul(ch.v[3], proof.eval_b))
		w0 = Fr.sub(w0, Fr.mul(ch.v[4], proof.eval_c))
		w0 = Fr.sub(w0, Fr.mul(ch.v[5], proof.eval_s1))
		w0 = Fr.sub(w0, Fr.mul(ch.v[6], proof.eval_s2))
		pol_wxi.set(w0, 0)

		pol_wxi = divPol1(pol_wxi, ch.xi)

		proof.Wxi = await expTau(pol_wxi, "multiexp Wxi")

		let pol_wxiw = new BigBuffer((zkey.domainSize + 3) * n8r)
		for (let i = 0; i < zkey.domainSize + 3; i++) {
			const w = pol_z.slice(i * n8r, (i + 1) * n8r)
			pol_wxiw.set(w, i * n8r)
		}
		w0 = pol_wxiw.slice(0, n8r)
		w0 = Fr.sub(w0, proof.eval_zw)
		pol_wxiw.set(w0, 0)

		pol_wxiw = divPol1(pol_wxiw, Fr.mul(ch.xi, Fr.w[zkey.power]))
		proof.Wxiw = await expTau(pol_wxiw, "multiexp Wxiw")
	}

	function hashToFr(transcript) {
		const v = Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(transcript)))
		return Fr.e(v)
	}


	function evalPol(P, x) {
		const n = P.byteLength / n8r
		if (n == 0) return Fr.zero
		let res = P.slice((n - 1) * n8r, n * n8r)
		for (let i = n - 2; i >= 0; i--) {
			res = Fr.add(Fr.mul(res, x), P.slice(i * n8r, (i + 1) * n8r))
		}
		return res
	}

	function divPol1(P, d) {
		const n = P.byteLength / n8r
		const res = new BigBuffer(n * n8r)
		res.set(Fr.zero, (n - 1) * n8r)
		res.set(P.slice((n - 1) * n8r, n * n8r), (n - 2) * n8r)
		for (let i = n - 3; i >= 0; i--) {
			res.set(
				Fr.add(
					P.slice((i + 1) * n8r, (i + 2) * n8r),
					Fr.mul(
						d,
						res.slice((i + 1) * n8r, (i + 2) * n8r)
					)
				),
				i * n8r
			)
		}
		if (!Fr.eq(
			P.slice(0, n8r),
			Fr.mul(
				Fr.neg(d),
				res.slice(0, n8r)
			)
		)) {
			throw new Error("Polinomial does not divide")
		}
		return res
	}

	async function expTau(b, name) {
		const n = b.byteLength / n8r
		const PTauN = PTau.slice(0, n * curve.G1.F.n8 * 2)
		const bm = await curve.Fr.batchFromMontgomery(b)
		let res = await curve.G1.multiExpAffine(PTauN, bm, null, name)
		res = curve.G1.toAffine(res)
		return res
	}


	async function to4T(A, pz) {
		pz = pz || []
		let a = await Fr.ifft(A)
		const a4 = new BigBuffer(n8r * zkey.domainSize * 4)
		a4.set(a, 0)

		const a1 = new BigBuffer(n8r * (zkey.domainSize + pz.length))
		a1.set(a, 0)
		for (let i = 0; i < pz.length; i++) {
			a1.set(
				Fr.add(
					a1.slice((zkey.domainSize + i) * n8r, (zkey.domainSize + i + 1) * n8r),
					pz[i]
				),
				(zkey.domainSize + i) * n8r
			)
			a1.set(
				Fr.sub(
					a1.slice(i * n8r, (i + 1) * n8r),
					pz[i]
				),
				i * n8r
			)
		}
		const A4 = await Fr.fft(a4)
		return [a1, A4]
	}
}

const vKey = JSON.parse(readFileSync('./build/vkey.json').toString())

const verify = async (publicSignals, forgedProof) => {
	const n = publicSignals[0]
	const result = await snarkjs.plonk.verify(vKey, publicSignals, forgedProof)

	if (result) {
		console.log(`[+] You really know the factor of ${n}!`)
	} else {
		console.log("[-] You don't know the factors")
	}
}

const main = async () => {
	console.log(`#### Goal: prove that we know the factors of n without reavealing its factors (n === p * q) to the verifier`)
	console.log('#### Submit a valid proof with the knowledge of private inputs (factors of "n")')
	
	const p = getRandomPrime(64)
	const q = getRandomPrime(64)
	const privateInputs = { p, q }
	
	console.log(`## Private Inputs (factors p, q): p = ${p}, q = ${q}`)
	console.log(`## p * q === ${p * q}`)

	const { proof: validProof, publicSignals } = await generatePlonkProof(privateInputs)
	
	await verify(publicSignals, validProof)

	console.log('################ HERE WE GO ################')
	console.log('#### Submit a forge proof without the knowledge of private inputs (factors of a random "n")')
	
	let foundForgeProof = false
	while (!foundForgeProof) {
		try {
			const { proof: forgeProof, publicSignals } = await generateForgedPlonkProof()
			
			await verify(publicSignals, forgeProof)
			
			const n = publicSignals[0]
			console.log(`#### We have successfully convinced the verifier that we konw the factors of ${n}`)
			console.log('#### Even though we have no idea what are its factors')
			
			foundForgeProof = true
		} catch (_) {}
	}
}

main()
	.then(() => process.exit(0))
	.catch((error) => {
		console.error(error)
		process.exit(1)
	})